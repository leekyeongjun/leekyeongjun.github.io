<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>Index</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
            /* New style for code blocks */
            pre, code {
                background-color: #f0f0f0; /* Light gray background */
                padding: 5px;
                border-radius: 5px;
                /*display: block;*/
                /*overflow-x: auto;*/
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <hr>
<h1 id="index">Index</h1>
<ul>
<li><a href="#index">Index</a></li>
<li><a href="#introduction">Introduction</a>
<ul>
<li><a href="#purpose">Purpose</a></li>
<li><a href="#system-spec">System Spec</a>
<ul>
<li><a href="#%EA%B8%B0%EA%B8%B0-%EC%82%AC%EC%96%91">기기 사양</a></li>
<li><a href="#xv6-%EC%A0%95%EB%B3%B4">xv6 정보</a></li>
</ul>
</li>
<li><a href="#implementation-schedule">Implementation Schedule</a></li>
</ul>
</li>
<li><a href="#design">Design</a>
<ul>
<li><a href="#1-understandings-of-basic-rr-scheduler-in-xv6">1. Understandings of Basic RR scheduler in xv6</a></li>
<li><a href="#2-fcfs-first-come-first-served-scheduler-implementation">2. FCFS (First-come-First-served) Scheduler Implementation</a>
<ul>
<li><a href="#1-specification">1. Specification</a></li>
<li><a href="#2-algorithm">2. Algorithm</a>
<ul>
<li><a href="#%EC%96%B4%EB%96%BB%EA%B2%8C-fcfs-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC%EB%A5%BC-%EA%B5%AC%ED%98%84%ED%95%A0%EA%B9%8C">어떻게 FCFS 스케줄러를 구현할까?</a></li>
<li><a href="#modifying-the-iterator-p">Modifying the Iterator, <code>p</code></a></li>
<li><a href="#system-call%EC%9D%84-%ED%86%B5%ED%95%B4-%ED%8A%B9%EC%A0%95-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EA%B0%80-yield-%ED%95%9C-%EA%B2%BD%EC%9A%B0-fcfs-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91%ED%95%B4%EC%95%BC-%ED%95%A0%EA%B9%8C">System call을 통해 특정 프로세스가 <code>yield</code> 한 경우, FCFS 스케줄러는 어떻게 동작해야 할까?</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-mlfq-multiple-level-feedback-queue--priority-scheduling">3. MLFQ (Multiple level feedback queue) &amp; Priority Scheduling</a>
<ul>
<li><a href="#1-specification-1">1. Specification</a></li>
<li><a href="#2-algorithm-1">2. Algorithm</a>
<ul>
<li><a href="#mlfq-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B5%AC%ED%98%84%ED%95%B4%EC%95%BC-%ED%95%A0%EA%B9%8C">MLFQ 스케줄러를 어떻게 구현해야 할까?</a></li>
<li><a href="#multiple-iteration---lock-problem">Multiple iteration - lock problem</a>
<ul>
<li><a href="#scheduler%EA%B0%80-context-switching-%ED%95%A0-process%EB%A5%BC-%EC%84%A0%ED%83%9D%ED%95%9C-%EA%B2%BD%EC%9A%B0">Scheduler가 Context switching 할 process를 선택한 경우</a></li>
<li><a href="#scheduler%EA%B0%80-context-switching%EC%9D%84-%ED%95%A0-process%EB%A5%BC-%EC%84%A0%ED%83%9D%ED%95%98%EC%A7%80-%EB%AA%BB%ED%95%9C-%EA%B2%BD%EC%9A%B0">Scheduler가 Context switching을 할 process를 선택하지 못한 경우</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-mode-switch-between-fcfs--mlfq-mode">4. Mode Switch between FCFS &amp; MLFQ Mode</a>
<ul>
<li><a href="#1-specification-2">1. Specification</a></li>
<li><a href="#2-algorithm-2">2. Algorithm</a>
<ul>
<li><a href="#fcfs-scheduler%EC%99%80-mlfq-scheduler%EC%9D%98-%ED%86%B5%ED%95%A9">FCFS Scheduler와 MLFQ Scheduler의 통합</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#implementation">Implementation</a>
<ul>
<li><a href="#1-fcfs-scheduler">1. FCFS Scheduler</a>
<ul>
<li><a href="#%EC%A0%84%EC%97%AD%EB%B3%80%EC%88%98-%EB%B0%8F-%ED%95%A8%EC%88%98-%EC%84%A4%EB%AA%85">전역변수 및 함수 설명</a>
<ul>
<li><a href="#kernelprocc"><code>kernel/proc.c</code></a></li>
</ul>
</li>
<li><a href="#scheduler"><code>scheduler()</code></a></li>
<li><a href="#related-system-call">Related System call</a>
<ul>
<li><a href="#kernelmysyscallc"><code>kernel/mysyscall.c</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-mlfq-scheduler">2. MLFQ Scheduler</a>
<ul>
<li><a href="#%EC%A0%84%EC%97%AD%EB%B3%80%EC%88%98-%EB%B0%8F-%ED%95%A8%EC%88%98-%EC%84%A4%EB%AA%85-1">전역변수 및 함수 설명</a>
<ul>
<li><a href="#kernelproch"><code>kernel/proc.h</code></a></li>
<li><a href="#kernelprocc-1"><code>kernel/proc.c</code></a></li>
<li><a href="#kerneltrapc"><code>kernel/trap.c</code></a></li>
</ul>
</li>
<li><a href="#scheduler-1"><code>scheduler()</code></a></li>
<li><a href="#related-system-call-1">Related System call</a>
<ul>
<li><a href="#kernelmysyscallc-1"><code>kernel/mysyscall.c</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-mode-change">3. Mode change</a>
<ul>
<li><a href="#%EC%A0%84%EC%97%AD%EB%B3%80%EC%88%98-%EB%B0%8F-%ED%95%A8%EC%88%98-%EC%84%A4%EB%AA%85-2">전역변수 및 함수 설명</a>
<ul>
<li><a href="#kernelprocc-2"><code>kernel/proc.c</code></a></li>
</ul>
</li>
<li><a href="#scheduler-2"><code>scheduler()</code></a></li>
<li><a href="#related-system-call-2">Related System call</a>
<ul>
<li><a href="#kernelmysyscallc-2"><code>kernel/mysyscall.c</code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#results">Results</a></li>
<li><a href="#troubleshooting">Troubleshooting</a></li>
</ul>
<hr>
<h1 id="introduction">Introduction</h1>
<h2 id="purpose">Purpose</h2>
<blockquote>
<p>Project01의 목적은 서로 다른 유형의 Scheduler를 구현하고, 이들 Scheduler 간의 전환을 가능하게 하는 것이다.</p>
</blockquote>
<p>이를 위해 xv6의 프로세스 관리방법, Interrupt 처리 방법, 기존 Scheduler의 구현 사항을 숙지해야 하며, 이에 더하여 FCFS, MLFQ Scheduler의 작동 원리를 이해하고 이를 구현할 수 있어야 한다.</p>
<h2 id="system-spec">System Spec</h2>
<h3 id="기기-사양">기기 사양</h3>
<pre><code>프로세서	12th Gen Intel(R) Core(TM) i7-1260P   2.10 GHz
설치된 RAM	16.0GB(15.7GB 사용 가능)
저장소	477 GB SSD SAMSUNG MZVL2512HCJQ-00BL7
그래픽 카드	Intel(R) UHD Graphics (128 MB)
시스템 종류	64비트 운영 체제, x64 기반 프로세서
</code></pre>
<h3 id="xv6-정보">xv6 정보</h3>
<pre><code>RISC-V 버전 xv6
Git classroom에 업로드된 xv6 소프트웨어를 clone 하여 구현하였음.

clone address : &quot;https://github.com/splab-ELE3021/project01-2019092824.git&quot;
</code></pre>
<h2 id="implementation-schedule">Implementation Schedule</h2>
<p><img src=".\imgs\download.png" alt=""></p>
<hr>
<h1 id="design">Design</h1>
<h2 id="1-understandings-of-basic-rr-scheduler-in-xv6">1. Understandings of Basic RR scheduler in xv6</h2>
<p>기존 xv6의 scheduler는 다음과 같이 동작한다.</p>
<pre><code class="language-c"><span class="hljs-keyword">for</span>(;;){
	<span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) {
      acquire(&amp;p-&gt;lock);
      <span class="hljs-keyword">if</span>(p-&gt;state == RUNNABLE) {
        p-&gt;state = RUNNING;
        c-&gt;proc = p;
        swtch(&amp;c-&gt;context, &amp;p-&gt;context);
		<span class="hljs-comment">// 다음 sched() 호출 시 여기부터 시작</span>
        c-&gt;proc = <span class="hljs-number">0</span>;
        found = <span class="hljs-number">1</span>;
      }
      release(&amp;p-&gt;lock);
    }
}
</code></pre>
<p><code>proc.c</code>의 <code>scheduler()</code> 함수는 Timer interrupt로 인해 <code>yield()</code>가 호출된 후, <code>sched()</code>를 거쳐 실행된다.
이때 <code>scheduler()</code> 함수의 program counter는 <code>swtch()</code> 가 발생한 바로 다음을 가리킨다.</p>
<p>주목해야 할 것은 <code>for loop</code>의 iteration 방법인데, <code>proc</code> Array를 Iteration 하는 포인터 <code>p</code> 가 증가하는 시점,
즉 <code>p++</code> 가 행해지는 시점을 명확히 할 필요가 있다. 아래 그림을 보자.</p>
<p><code>select</code> 변수는 다음에 스케줄링 할 프로세스를 가리키는 포인터 (<code>struct proc *</code>)이다.</p>
<p><img src=".\imgs\Pasted%20image%2020250412191153.png" alt=""></p>
<p>여기서 확인할 수 있듯이, 만약 <code>for loop</code> 도중 <code>swtch</code> 가 호출되어 context switch 가 발생하면, <code>scheduler</code>내의 iterator <code>p</code> 값은 선택된 프로세스에 <strong>정지한다</strong>. 이는 다시금 <code>yield</code>가 호출되어 context switch 가 발생, <code>scheduler</code>로 복귀했을 때 증가하게 된다. 즉, process가 선택된 다음 Round에, 전 Round에 선택되었던 process는 후순위로 밀린다는 것.</p>
<p>따라서, 자연스럽게 기존 xv6의 <code>scheduler</code>는 process의 생성 순서대로 <strong>순차적으로</strong> 스케줄링되는 Round Robin의 형태를 갖게 된다.</p>
<h2 id="2-fcfs-first-come-first-served-scheduler-implementation">2. FCFS (First-come-First-served) Scheduler Implementation</h2>
<h3 id="1-specification">1. Specification</h3>
<ul>
<li>기존 Scheduler의 변형일 것.</li>
<li>PCB에 어떠한 조작도 가하지 않을 것. (변수 추가 등)</li>
<li>생성 순서대로 프로세스를 선택할 것.</li>
<li>프로세스가 선택되면, <code>TERMINATE</code> 되거나 스스로 <code>yield</code> 하지 않는 한 계속 프로세스 실행 권한을 유지할 것.</li>
<li>커널 주요 부분을 수정할 것.</li>
</ul>
<h3 id="2-algorithm">2. Algorithm</h3>
<h4 id="어떻게-fcfs-스케줄러를-구현할까">어떻게 FCFS 스케줄러를 구현할까?</h4>
<p>FCFS 스케줄링을 실현할 수 있는 방법은 크게 두가지가 있다.</p>
<ol>
<li><code>proc.c</code>의 <code>scheduler</code> 내부에서 FCFS 처럼 동작하도록 하는 것.</li>
<li>타이머 인터럽트를 꺼버리는 것.</li>
</ol>
<p><img src=".\imgs\Pasted%20image%2020250412191321.png" alt=""></p>
<p>위 삽화는 각각 1번과 2번 방법을 도식화 한 것이다.
이 중 <em>1번 방법</em> 을 선택하였으며, 근거는 아래와 같다.</p>
<ul>
<li>타이머 인터럽트를 끄면 FCFS 스케줄링을 간단히 구현할 수 있다.
<ul>
<li>매 Tick 마다 <code>yield()</code>가 실행되지 않기 때문이다.</li>
</ul>
</li>
<li>그러나 이 방법을 사용해 FCFS 스케줄링을 하게 되면 MLFQ 스케줄러와의 <strong>모드 전환이 어려워 진다.</strong>
<ul>
<li>예컨대 Process 4와 Process 5가 각각 있다고 하자.
<ul>
<li>P4는 P5의 부모 프로세스다. 즉 <code>proc</code> 배열 기준 P4의 index가 P5보다 먼저다.
<ul>
<li>MLFQ로 스케줄링 하는 상황, <strong>P5 프로세스 실행 중</strong>에 모드가 <strong>FCFS로 바뀌면</strong> 그 다음 scheduing round 부터는 정상적인 FCFS 스케줄러 였을 때 <strong>P4</strong>로 Context switch가 발생해야 한다.</li>
<li>그러나 타이머 인터럽트를 꺼버리면 그냥 P5가 끝날 때 까지 실행하게 되며, 이는 우리가 원하는 바가 아니다.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>좋다. 1번 방법을 이용해 FCFS 스케줄러를 구현할 것이다.
어떻게 구현할 수 있을까?</p>
<p>앞서 xv6의 원래 scheduler에서의 <strong>Iterator <code>p</code>의 이동 조건</strong> 에 조작을 가하면, 간단히 구현할 수 있다.</p>
<h4 id="modifying-the-iterator-p">Modifying the Iterator, <code>p</code></h4>
<p><img src=".\imgs\Pasted%20image%2020250412191344.png" alt=""></p>
<p>기존 스케줄러의 스케줄링 방법이다.</p>
<p>Iterator <code>p</code>가 <code>sched()</code> 직후 context restore 시점에 <strong>무조건 하나 늘어나기 때문에</strong> (다음 process를 가리키기 때문에),
이 상황에서는 FCFS가 성립되지 않는다.</p>
<p>FCFS 가 되려면 아래와 같이 되어야 한다.</p>
<p><img src=".\imgs\Pasted%20image%2020250412191406.png" alt="">
<img src=".\imgs\Pasted%20image%2020250412191417.png" alt=""></p>
<p>위 Flow를 보자.</p>
<p>context switch 할 프로세스를 선택한 시점에, <code>Iterator p</code>를 <code>proc</code>으로, 즉 프로세스 테이블 배열의 <strong>첫번째 인덱스</strong>로 초기화하고 있다. 이러면 첫번째 인덱스의 프로세스가 <code>TERMINATED</code>, 혹은 <code>SLEEP</code>하기 전 까지 <code>p</code>는 계속 <code>RUNNABLE</code> 한 첫번째 프로세스를 가리키게 될 것이다. FCFS의 결과와 정확히 동일하다.</p>
<p>다만 이렇게 구현할 경우 문제가 생긴다. <code>yield()</code>의 호출이 프로세스의 CPU 포기와 무관해진다.
P1이 <code>yield()</code>를 해서 CPU를 포기해봤자, 위 scheduling policy 하에선 어짜피 P1이 다시 선택되기 때문이다.</p>
<h4 id="system-call을-통해-특정-프로세스가-yield-한-경우-fcfs-스케줄러는-어떻게-동작해야-할까">System call을 통해 특정 프로세스가 <code>yield</code> 한 경우, FCFS 스케줄러는 어떻게 동작해야 할까?</h4>
<p>본 문제를 해결하기 위해, 반드시 선행되어야 하는 개념이 있다.</p>
<p><strong>Timer interrupt</strong>로 인해 호출되는 <code>yield()</code>와, <strong>System call</strong>에 의해 호출되는 <code>yield()</code>는 <strong>다르게</strong> 취급되어야 한다.
그 이유는 프로세스가 자신의 cpu 점유를 놓고자 하는 &quot;<strong>의도의 유무</strong>&quot;와 크게 관련이 있다.</p>
<p>Timer interrupt로 인해 호출되는 <code>yield()</code>는 preemptive 하다. 시간이 되면 반드시 호출되므로 프로세스의 의도와는 관계없이 CPU를 놔야 한다. 기존 코드의 수정으로 <code>scheduler</code>를 FCFS로 바꿨으니, 그 프로세스가 <code>RUNNABLE</code> 해졌다가 다시 <code>RUNNING</code> 상태로 전환되는 것은 변함이 없다. 즉 Timer interrupt에 의한 <code>yield()</code>는 별 신경 안써도 된다.</p>
<p>문제는 yield system call에 의한 <code>yield()</code>이다. 이 경우 프로세스는 명확히 <strong>CPU를 놓고자 하는 의도</strong>가 있다.
따라서 이를 존중해야 한다.</p>
<p><img src=".\imgs\Pasted%20image%2020250412191531.png" alt=""></p>
<p>위 삽화에서 볼 수 있듯, scheduler로 도달하게 한 <code>yield()</code>가 <strong>timer interrupt</strong> 기반인지, <strong>system call</strong> 기반인지에 따라 스케줄러는 다르게 동작해야 한다.</p>
<p>System call에 의해 특정 프로세스가 <code>yield()</code>를 호출할 경우, 그 프로세스의 <code>pid</code>를 저장하는 변수를 하나 둠으로써
이 문제를 해결할 수 있다.</p>
<p><code>yieldpid</code>가 바로 그 변수이다.</p>
<p><img src=".\imgs\Pasted%20image%2020250412191540.png" alt="">
<img src=".\imgs\Pasted%20image%2020250412191547.png" alt=""></p>
<p>위 그림처럼 P1이 yield system call로 <code>yield()</code>를 호출했다면, 그 Round에는 P1을 <strong>배제해야 한다.</strong>
그 이후에 다시 timer interrupt에 의해 <code>yield()</code>가 호출됐다면, 그때 다시 P1을 선택하면 된다.</p>
<p>왜냐하면 P1은 <code>yield</code>를 한 것이지, <code>SLEEP</code> 이나 <code>TERMINATED</code> 된 것이 아니기 때문이다.
yield System call이 호출된 시점의 Scheduling Round에서만 배제하면 된다.</p>
<h2 id="3-mlfq-multiple-level-feedback-queue--priority-scheduling">3. MLFQ (Multiple level feedback queue) &amp; Priority Scheduling</h2>
<h3 id="1-specification-1">1. Specification</h3>
<ul>
<li>각 프로세스는 3개의 Queue(L0, L1, L2)에 속한다.
<ul>
<li>L0 : 1tick의 time quantum</li>
<li>L1 : 3tick의 time quantum</li>
<li>L2 : 5tick의 time quantum, priority 적용됨.</li>
</ul>
</li>
<li>새로운 프로세스 생성시 L0으로 배치된다.</li>
<li>각 Queue에서의 RUNNABLE 한 프로세스가 없으면, 하위 큐에서 찾는다.</li>
<li>각 Queue에서 time quantum을 전부 소모한 프로세스는 Demotion 한다.</li>
<li>L2 Queue는 Priority가 적용되며, 높은 Priority를 가진 프로세스가 먼저 실행된다. (3~0 순)</li>
<li>Global tick이 50이 될 때, Priority Boosting이 발생한다.
<ul>
<li>모든 프로세스의 Queue를 0으로 초기화하며, Time quantum 역시 초기화 한다.</li>
</ul>
</li>
</ul>
<h3 id="2-algorithm-1">2. Algorithm</h3>
<h4 id="mlfq-스케줄러를-어떻게-구현해야-할까">MLFQ 스케줄러를 어떻게 구현해야 할까?</h4>
<p>MLFQ는 L0 ~ L3 큐를 순회하며 <code>RUNNABLE</code> 한 프로세스를 찾아야 한다.
따라서 한번의 Iteration 만으로 가능했던 FCFS와는 달리 Iteration이 여러번 일어나야 한다.</p>
<p><img src=".\imgs\Pasted%20image%2020250412191615.png" alt=""></p>
<p>위 삽화는 MLFQ 프로세스의 동작을 도식화한 것이다.
<code>s</code>는 <code>p</code>를 통한 프로세스 테이블의 탐색이 마무리 된 이후, Context를 switch 할 프로세스를 가리킨다.
<code>lastpid</code>는 FCFS의 <code>yieldpid</code>와 유사하나, <code>lastpid</code>의 경우 yield system call과 timer interrupt로 인해 호출된 <code>yield()</code>를 <strong>구분하지 않고</strong>, <code>yield</code>한 프로세스의 pid를 저장하고 있는 변수다.</p>
<p>크게 3가지 부분을 중점적으로 살펴보자.</p>
<ol>
<li>프로세스의 PCB에는 어떤 데이터가 추가되어야 하는가?
<ul>
<li>현재 <code>queue number</code>, 현재 사용중인 <code>Time quantum</code>, L2 큐 스케줄링을 위한 <code>priority</code>가 필요하다.</li>
</ul>
</li>
<li>프로세스의 tq(time quantum)는 <strong>언제 소모되어야 하는가?</strong>
<ul>
<li>Timer interrupt가 실행되어 <code>yield()</code>가 호출된 시점에, 프로세스를 <code>RUNNABLE</code> 로 만들기 전 소모하면 된다.</li>
</ul>
</li>
<li>Iteration은 <strong>몇 번 일어나야 하는가?</strong>
<ul>
<li>Scheduler 내부에서 최소 <strong>1번</strong>, 많으면 <strong>9번</strong> 일어날 수 있다.
<ul>
<li>프로세스 전체의 갯수가 64개 이하이고, Queue 갯수가 3개, 그 중 Priority를 쓰는 L2 Queue의 경우 Priority 가 0, 1, 2, 3 4개 이므로
<ul>
<li>1(priority boosting) + 1 (tq 소모가 다 안됐을 경우) + 1 (tq 소모 다 한 프로세스 Demotion) + 1 (L0) + 1(L1) + 4(L2 priority 4개) = 9</li>
<li><strong>최대 576 cycle 이내에 MLFQ 스케줄링은 마무리 된다.</strong>
<ul>
<li>개발 머신이 2.1Ghz frequency를 가지므로, wsl, qemu등의 속도 저해 요소를 배제하고 xv6가 본 머신의 main OS일 경우 100ms 이내에 스케줄링이 끝난다.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>위 모형을 바탕으로 MLFQ 스케줄러의 <strong>Pseudo code</strong>는 아래와 같다.</p>
<p><img src=".\imgs\Pasted%20image%2020250412191623.png" alt=""></p>
<ul>
<li>Scheduler가 호출되면, 다음에 선택될 프로세스<code>select</code>를 선택하기 위해 Process Table을 여러번 iteration하게 된다.
<ul>
<li>만일 <code>yield()</code>를 호출한 프로세스의 Time quantum이 남아있다면, 그 프로세스를 그대로 선택하면 된다.
<ul>
<li>따라서 <code>yield()</code> 를 호출한 Process의 pid를 Scheduler는 인지하고 있어야 한다. 이를 <code>lastpid</code>로 정의하였으며, FCFS의 <code>yieldpid</code>와는 다르게 <code>lastpid</code>는 System call과 Timer Interrupt를 구분하지 않고 해당 프로세스의 pid를 저장한다.</li>
</ul>
</li>
</ul>
</li>
<li>본 project01에서는 MLFQ 스케줄러 하에서 System call에 의해 <code>yield()</code>를 호출한 프로세스의 Time quantum 변화에 대해 기술되어 있지 않다.
<ul>
<li>따라서 MLFQ에서의 yield system call 호출이 일어났을 때에도 일괄적으로 Time quantum을 감소시켰다.</li>
</ul>
</li>
</ul>
<h4 id="multiple-iteration---lock-problem">Multiple iteration - lock problem</h4>
<p>스케줄러 내부에서 여러번 Iteration을 하려면, lock을 <strong>acquire하고, release 하는 시점</strong>에 대한 이해가 필요하다.
우선 iterator <code>p</code>가 process table을 iterating 하는 도중, lock을 얻는 이유는 PCB 내의 데이터는 <strong>Critical section</strong>이기 때문으로, 해당 값을 변화시키는 것은 <strong>atomic</strong> 하게 동작해야 하기 때문이다.</p>
<p>따라서 Iteration 종료 이후 <code>swtch()</code>를 하려면, 해당 프로세스의 lock이 언제 잠기고 풀리는지 파악할 필요가 있다.
아래 그림은 Iteration 바깥에서 context switch를 하는 중, 해당 프로세스의 lock이 어떻게 다뤄지는지에 대한 과정을 묘사하고 있다.</p>
<h5 id="scheduler가-context-switching-할-process를-선택한-경우">Scheduler가 Context switching 할 process를 선택한 경우</h5>
<p><img src=".\imgs\Pasted%20image%2020250412191639.png" alt="">
<img src=".\imgs\Pasted%20image%2020250412191702.png" alt="">
<img src=".\imgs\Pasted%20image%2020250412191709.png" alt=""></p>
<h5 id="scheduler가-context-switching을-할-process를-선택하지-못한-경우">Scheduler가 Context switching을 할 process를 선택하지 못한 경우</h5>
<p><img src=".\imgs\Pasted%20image%2020250412191724.png" alt="">
<img src=".\imgs\Pasted%20image%2020250412191735.png" alt=""></p>
<p>위 코드를 바탕으로, Pseudo code의 <strong>multiple iteration</strong>을 실현할 수 있다.</p>
<h2 id="4-mode-switch-between-fcfs--mlfq-mode">4. Mode Switch between FCFS &amp; MLFQ Mode</h2>
<h3 id="1-specification-2">1. Specification</h3>
<ul>
<li>부팅 시 초기 스케줄러 모드는 FCFS이다.
<ul>
<li>FCFS 모드 하에서 Priority boosting은 발생하지 않는다.</li>
</ul>
</li>
<li>모드간의 변화가 발생하면 Global tick count는 0으로 초기화 된다.</li>
<li>동일한 모드로의 변화는 에러 메시지를 출력하며, 아무런 변화가 일어나지 않는다.</li>
<li>MLFQ -&gt; FCFS (<code>fcfsmode()</code>)
<ul>
<li>모든 프로세스의 Queue, time quantum, Priority를 -1로 초기화한다.</li>
<li>다음부터 프로세스의 Scheduling은 오직 Creation time에 의존한다(FCFS).</li>
</ul>
</li>
<li>FCFS -&gt; MLFQ (<code>mlfqmode()</code>)
<ul>
<li>모든 프로세스는 L0 Queue로, Priority는 1로 초기화한다.</li>
<li>다음부터 프로세스의 Scheduling은 MLFQ에 따른다.</li>
</ul>
</li>
</ul>
<h3 id="2-algorithm-2">2. Algorithm</h3>
<h4 id="fcfs-scheduler와-mlfq-scheduler의-통합">FCFS Scheduler와 MLFQ Scheduler의 통합</h4>
<p><img src=".\imgs\Pasted%20image%2020250412201321.png" alt=""></p>
<p>위 다이어그램은 FCFS와 MLFQ 스케줄러를 통합한 것이다. 몇가지 살펴볼 점이 있다.</p>
<ul>
<li><strong>Previous mode는 왜 검사하는가?</strong>
<ul>
<li>FCFS Scheduler는 <strong>for loop 내부</strong>에서 선택될 프로세스를 정하고, <code>swtch()</code>까지 진행한다.</li>
<li>따라서 다음 Scheduling round 가 도달하기 전 모드가 MLFQ로 바뀌더라도, 여전히 Scheduler의 context는 <strong>FCFS의 loop</strong>를 도는 상태로 복귀한다.
<ul>
<li>이를 예방하기 위해 FCFS에서 MLFQ로 모드 변환이 발생한 경우 의도적으로 FCFS의 loop를 깨고, 다시 Scheduling Mode를 검사하는 절차가 필요하다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src=".\imgs\Pasted%20image%2020250412202444.png" alt=""></p>
<ul>
<li>MLFQ 역시 Scheduling round에 도달하기 전 FCFS로 바뀌었을 경우를 고려해야 하나, MLFQ의 경우에는 <code>swtch()</code>가 loop 바깥에 있기 때문에 명시적으로 loop를 깨라고 지시할 필요가 없다.
<ul>
<li>MLFQ의 경우에는 <code>swtch()</code>가 발생하면 MLFQ 분기를 빠져나오며, 다시 검사가 가능하다.</li>
</ul>
</li>
</ul>
<p><img src=".\imgs\Pasted%20image%2020250412202650.png" alt=""></p>
<h1 id="implementation">Implementation</h1>
<h2 id="1-fcfs-scheduler">1. FCFS Scheduler</h2>
<h3 id="전역변수-및-함수-설명">전역변수 및 함수 설명</h3>
<h4 id="kernelprocc"><code>kernel/proc.c</code></h4>
<pre><code class="language-c"><span class="hljs-comment">// ==================================================================</span>
<span class="hljs-comment">// 기존 코드 생략..</span>
<span class="hljs-comment">// ==================================================================</span>

<span class="hljs-comment">// If yield is called by syscall, this is the pid of the process</span>
<span class="hljs-type">int</span> yieldpid = <span class="hljs-number">0</span>;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">yieldpid_lock</span>;</span>

<span class="hljs-comment">// ==================================================================</span>
<span class="hljs-comment">// 기존 코드 생략..</span>
<span class="hljs-comment">// ==================================================================</span>

<span class="hljs-comment">// initialize the proc table.</span>
<span class="hljs-type">void</span>
<span class="hljs-title function_">procinit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span>
  
  initlock(&amp;pid_lock, <span class="hljs-string">&quot;nextpid&quot;</span>);
  initlock(&amp;wait_lock, <span class="hljs-string">&quot;wait_lock&quot;</span>);
  initlock(&amp;schedmode_lock, <span class="hljs-string">&quot;schedmode_lock&quot;</span>);
  initlock(&amp;yieldpid_lock, <span class="hljs-string">&quot;yieldpid_lock&quot;</span>);
  initlock(&amp;lastpid_lock, <span class="hljs-string">&quot;lastpid_lock&quot;</span>);

  <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) {
      initlock(&amp;p-&gt;lock, <span class="hljs-string">&quot;proc&quot;</span>);
      p-&gt;state = UNUSED;
      p-&gt;qnum = FCFSMODE;
      p-&gt;tq = FCFSMODE;
      p-&gt;priority = FCFSMODE;
      p-&gt;kstack = KSTACK((<span class="hljs-type">int</span>) (p - proc));
  }
}

<span class="hljs-comment">// ==================================================================</span>
<span class="hljs-comment">// 기존 코드 생략..</span>
<span class="hljs-comment">// ==================================================================</span>

<span class="hljs-comment">// 0 : nothing yielded voluntarily </span>
<span class="hljs-comment">// else : pid of the process that yielded on a syscall</span>
<span class="hljs-type">int</span>
<span class="hljs-title function_">yieldp</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> 
{
  <span class="hljs-type">int</span> pid;
  acquire(&amp;yieldpid_lock);
  pid = yieldpid;
  release(&amp;yieldpid_lock);
  <span class="hljs-keyword">return</span> pid;
}

<span class="hljs-comment">// 0 : default(no yield)</span>
<span class="hljs-comment">// else : pid of the process that yielded on a syscall</span>
<span class="hljs-type">int</span>
<span class="hljs-title function_">setyieldpid</span><span class="hljs-params">(<span class="hljs-type">int</span> pid)</span> 
{
  acquire(&amp;yieldpid_lock);
  yieldpid = pid;
  release(&amp;yieldpid_lock);
  <span class="hljs-keyword">return</span> yieldpid;
}
</code></pre>
<ul>
<li>Variables</li>
</ul>
<table>
<thead>
<tr>
<th>Type</th>
<th>Name</th>
<th>역할</th>
<th>사용</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>int</code></td>
<td><code>yieldpid</code></td>
<td>FCFS 모드 중, System call로 yield한 프로세스의 pid를 저장하는 함수</td>
<td><code>proc.c</code></td>
</tr>
<tr>
<td><code>struct spinlock</code></td>
<td><code>yieldpid_lock</code></td>
<td><code>yieldpid</code>는 한번에 하나의 프로세스만이 설정해야 하므로, 이를 위한 lock</td>
<td><code>proc.c</code></td>
</tr>
</tbody>
</table>
<ul>
<li>Functions</li>
</ul>
<table>
<thead>
<tr>
<th>Return value</th>
<th>Name(args)</th>
<th>역할</th>
<th>사용</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>int</code></td>
<td><code>yieldp(void)</code></td>
<td>Scheduling round에서 혹시 System call에 의한 yielded process가 있는지 확인하는 함수.<br>0 : 해당 라운드에 yield Syscall로 yield한 프로세스 없음.<br>그 외 값 : yield Syscall로 yield한 프로세스의 <code>pid</code></td>
<td><code>proc.c</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>setyieldpid(int pid)</code></td>
<td>Syscall에 의한 yield일 경우, 이 함수를 호출하여 <code>yieldpid</code>를 Set</td>
<td><code>mysyscall.c</code></td>
</tr>
</tbody>
</table>
<h3 id="scheduler"><code>scheduler()</code></h3>
<pre><code class="language-c"><span class="hljs-type">void</span>
<span class="hljs-title function_">scheduler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cpu</span> *<span class="hljs-title">c</span> =</span> mycpu();

  <span class="hljs-comment">// FCFS only</span>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">fcfs_select</span> =</span> <span class="hljs-number">0</span>;
  <span class="hljs-type">int</span> fcfs_selected = <span class="hljs-number">0</span>;

  c-&gt;proc = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span>(;;){

    intr_on();
    <span class="hljs-type">int</span> found = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC];) {
      acquire(&amp;p-&gt;lock);
      <span class="hljs-keyword">if</span>(p-&gt;state == RUNNABLE) {
	    <span class="hljs-keyword">if</span>(yieldp() == <span class="hljs-number">0</span>){ <span class="hljs-comment">// if nothing voluntarily yielded</span>
		  fcfs_select = p;
		  fcfs_select -&gt; state = RUNNING;
		  c -&gt; proc = fcfs_select;
		  fcfs_selected = <span class="hljs-number">1</span>;
		  swtch(&amp;c-&gt;context, &amp;fcfs_select-&gt;context);
        }
        <span class="hljs-keyword">else</span>{ <span class="hljs-comment">// if something voluntarily yielded, you have to respect that intention</span>
          <span class="hljs-keyword">if</span>(p-&gt;pid != yieldp()){
            fcfs_select = p;
            fcfs_select -&gt; state = RUNNING;
            c -&gt; proc = fcfs_select;
	        fcfs_selected = <span class="hljs-number">1</span>;
            setyieldpid(<span class="hljs-number">0</span>); <span class="hljs-comment">// We handled this, so reset it</span>
            swtch(&amp;c-&gt;context, &amp;fcfs_select-&gt;context);
          }
        }
        c-&gt;proc = <span class="hljs-number">0</span>;
        found = <span class="hljs-number">1</span>;
        release(&amp;p-&gt;lock);     
        
        <span class="hljs-keyword">if</span>(fcfs_selected == <span class="hljs-number">1</span>){
          <span class="hljs-comment">// if we select a process, p should be reset.</span>
          p = proc;
          fcfs_selected = <span class="hljs-number">0</span>;
        }<span class="hljs-keyword">else</span> {
          <span class="hljs-comment">// if we are not able to find a process, we should move to the next one.</span>
          p++;
        }
    }
    <span class="hljs-keyword">if</span>(found == <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// nothing to run; stop running on this core until an interrupt.</span>
      intr_on();
      <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;wfi&quot;</span>)</span>;
    }
}
</code></pre>
<ul>
<li>Local variables</li>
</ul>
<table>
<thead>
<tr>
<th>Type</th>
<th>Name</th>
<th>역할</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>struct proc *</code></td>
<td><code>p</code></td>
<td>Process table의 iterator.</td>
</tr>
<tr>
<td><code>struct proc *</code></td>
<td><code>fcfs_select</code></td>
<td>Scheduling round 종료 시점에 <code>swtch()</code>할 프로세스를 가리키는 포인터.</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>fcfs_selected</code></td>
<td>Iteration 종료 시점에 <code>fcfs_select</code>가 정해졌는지 아닌지 여부를 나타내는 변수.<br>0 : 선택되지 않음 (default)<br>1 : 선택 됨</td>
</tr>
</tbody>
</table>
<ul>
<li>Specification 반영사항</li>
</ul>
<table>
<thead>
<tr>
<th>Specification</th>
<th>Line Number</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>기존 Scheduler의 변형일 것</td>
<td>전체</td>
<td>Timer interrupt를 끄는 방향으로 구현하지 않았음</td>
</tr>
<tr>
<td>PCB에 어떠한 조작도 가하지 않을 것 (변수 추가 등)</td>
<td><code>proc.h</code></td>
<td>FCFS만을 위한 변수 추가는 없었음</td>
</tr>
<tr>
<td>생성 순서대로 프로세스 선택할 것</td>
<td>45~52</td>
<td>Process가 생성 순서대로 프로세스 테이블에 들어온다는 성질을 이용, Iterator를 움직일지 말지 결정하며 스케줄링을 구현함</td>
</tr>
<tr>
<td>프로세스가 선택되면, <code>TERMINATE</code> 되거나 스스로 <code>yield</code> 하지 않는 한 계속 프로세스 실행 권한을 유지할 것.</td>
<td>22, 30</td>
<td>Syscall에 의한 yield를 구별하였음.</td>
</tr>
</tbody>
</table>
<ul>
<li>Design 반영사항</li>
</ul>
<table>
<thead>
<tr>
<th>Design</th>
<th>Line Number</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>어떻게 FCFS 스케줄러를 구현할까?</td>
<td>전체</td>
<td>Scheduler의 변형으로 구현하였음.</td>
</tr>
<tr>
<td>Modifying the iterator, <code>p</code></td>
<td>45~52</td>
<td>다음 프로세스의 선택 여부에 따라 Iterator의 이동 여부가 결정됨.</td>
</tr>
<tr>
<td>System call을 통해 특정 프로세스가 <code>yield</code> 한 경우, FCFS 스케줄러는 어떻게 동작해야 할까?</td>
<td>22, 30</td>
<td>System call을 통해 yield한 프로세스를 scheduling round에서 배제.</td>
</tr>
</tbody>
</table>
<h3 id="related-system-call">Related System call</h3>
<h4 id="kernelmysyscallc"><code>kernel/mysyscall.c</code></h4>
<pre><code class="language-c"><span class="hljs-comment">// ==================================================================</span>
<span class="hljs-comment">// 기존 코드 생략..</span>
<span class="hljs-comment">// ==================================================================</span>

<span class="hljs-type">void</span>
<span class="hljs-title function_">sys_yield</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>{
	setyieldpid(myproc()-&gt;pid);
    yield();
    <span class="hljs-keyword">return</span>;
}
</code></pre>
<ul>
<li>Functions</li>
</ul>
<table>
<thead>
<tr>
<th>Return value</th>
<th>Name(args)</th>
<th>역할</th>
<th>사용</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void</code></td>
<td><code>sys_yield(void)</code></td>
<td><code>yield()</code> 의 wrapper function. <code>setyieldpid()</code>를 통해 호출한 프로세스의 pid를 저장한다.</td>
<td>User program</td>
</tr>
</tbody>
</table>
<h2 id="2-mlfq-scheduler">2. MLFQ Scheduler</h2>
<h3 id="전역변수-및-함수-설명-1">전역변수 및 함수 설명</h3>
<h4 id="kernelproch"><code>kernel/proc.h</code></h4>
<pre><code class="language-c"><span class="hljs-comment">// ==================================================================</span>
<span class="hljs-comment">// 기존 코드 생략..</span>
<span class="hljs-comment">// ==================================================================</span>

<span class="hljs-comment">// Per-process state</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> {</span>

  <span class="hljs-comment">// ==================================================================</span>
  <span class="hljs-comment">// 기존 코드 생략..</span>
  <span class="hljs-comment">// ==================================================================</span>
  
  <span class="hljs-type">int</span> tq;                      <span class="hljs-comment">// Time quantum (1,3,5)</span>
  <span class="hljs-type">int</span> qnum;                    <span class="hljs-comment">// Queue num(0-2)</span>
  <span class="hljs-type">int</span> priority;                <span class="hljs-comment">// Process priority (0-3)</span>
  
  <span class="hljs-comment">// ==================================================================</span>
  <span class="hljs-comment">// 기존 코드 생략..</span>
  <span class="hljs-comment">// ==================================================================</span>
};

<span class="hljs-meta">#<span class="hljs-keyword">define</span> TQ_Q0 1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> TQ_Q1 3</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> TQ_Q2 5</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> FCFSMODE -1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> TIMEQUANTUM(x) ((x) == 0 ? TQ_Q0 : (x) == 1 ? TQ_Q1 : (x) == 2 ? TQ_Q2 : FCFSMODE)</span>
</code></pre>
<ul>
<li>Variables</li>
</ul>
<table>
<thead>
<tr>
<th>변수 명</th>
<th>역할</th>
<th>사용</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>int tq</code></td>
<td>MLFQ 에서 프로세스 별 사용한 time quantum 값. 0에서 시작하여 <strong>점점 증가함</strong>.</td>
<td><code>proc.c</code></td>
</tr>
<tr>
<td><code>int qnum</code></td>
<td>MLFQ 에서 프로세스의 큐 위치, 0, 1, 2는 각각 L0, L1, L2 큐를 의미함.</td>
<td><code>proc.c</code>, <code>mysyscall.c</code></td>
</tr>
<tr>
<td><code>int priority</code></td>
<td>MLFQ, L2 큐 스케줄링에서 사용할 우선도 값 , 초기값은 3으로 시작함.</td>
<td><code>proc.c</code>, <code>mysyscall.c</code></td>
</tr>
<tr>
<td><code>TQ_QN</code></td>
<td>MLFQ에서 N번째 큐의 Time quantum limit 값</td>
<td><code>proc.c</code></td>
</tr>
<tr>
<td><code>TIMEQUANTUM(x)</code></td>
<td>MLFQ에서 <code>qnum</code>을 넣으면 해당하는 <code>TQ_Qn</code> 값으로 치환됨. FCFS 모드일 경우 -1.</td>
<td><code>proc.c</code></td>
</tr>
</tbody>
</table>
<h4 id="kernelprocc-1"><code>kernel/proc.c</code></h4>
<pre><code class="language-c"><span class="hljs-comment">// ==================================================================</span>
<span class="hljs-comment">// 기존 코드 생략..</span>
<span class="hljs-comment">// ==================================================================</span>

<span class="hljs-comment">// which process was last scheduled</span>
<span class="hljs-comment">// only used in MLFQ</span>
<span class="hljs-type">int</span> lastpid = <span class="hljs-number">0</span>;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lastpid_lock</span>;</span>


<span class="hljs-comment">// initialize the proc table.</span>
<span class="hljs-type">void</span>
<span class="hljs-title function_">procinit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span>
  
  initlock(&amp;pid_lock, <span class="hljs-string">&quot;nextpid&quot;</span>);
  initlock(&amp;wait_lock, <span class="hljs-string">&quot;wait_lock&quot;</span>);
  initlock(&amp;schedmode_lock, <span class="hljs-string">&quot;schedmode_lock&quot;</span>);
  initlock(&amp;yieldpid_lock, <span class="hljs-string">&quot;yieldpid_lock&quot;</span>);
  initlock(&amp;lastpid_lock, <span class="hljs-string">&quot;lastpid_lock&quot;</span>);

  <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) {
      initlock(&amp;p-&gt;lock, <span class="hljs-string">&quot;proc&quot;</span>);
      p-&gt;state = UNUSED;
      p-&gt;qnum = FCFSMODE;
      p-&gt;tq = FCFSMODE;
      p-&gt;priority = FCFSMODE;
      p-&gt;kstack = KSTACK((<span class="hljs-type">int</span>) (p - proc));
  }
}

<span class="hljs-comment">// ==================================================================</span>
<span class="hljs-comment">// 기존 코드 생략..</span>
<span class="hljs-comment">// ==================================================================</span>

<span class="hljs-comment">// Create a new process, copying the parent.</span>
<span class="hljs-comment">// Sets up child kernel stack to return as if from fork() system call.</span>
<span class="hljs-type">int</span>
<span class="hljs-title function_">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
  <span class="hljs-type">int</span> i, pid;
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">np</span>;</span>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();

  <span class="hljs-comment">// ==================================================================</span>
  <span class="hljs-comment">// 기존 코드 생략..</span>
  <span class="hljs-comment">// ==================================================================</span>
  
  <span class="hljs-type">int</span> mode = schedmode();
  acquire(&amp;np-&gt;lock);
  <span class="hljs-keyword">if</span>(mode == <span class="hljs-number">0</span>){
    <span class="hljs-comment">// FCFS</span>
    np-&gt;qnum = FCFSMODE;
    np-&gt;tq = FCFSMODE;
    np-&gt;priority = FCFSMODE;
  }
  <span class="hljs-keyword">else</span>{
    <span class="hljs-comment">// MLFQ</span>
    np-&gt;qnum = <span class="hljs-number">0</span>;
    np-&gt;tq = <span class="hljs-number">0</span>;
    np-&gt;priority = <span class="hljs-number">3</span>;
  }
  np-&gt;state = RUNNABLE;
  release(&amp;np-&gt;lock);

  <span class="hljs-keyword">return</span> pid;
}

<span class="hljs-comment">// ==================================================================</span>
<span class="hljs-comment">// 기존 코드 생략..</span>
<span class="hljs-comment">// ==================================================================</span>

<span class="hljs-comment">// Give up the CPU for one scheduling round.</span>
<span class="hljs-type">void</span>
<span class="hljs-title function_">yield</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
  
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();
  acquire(&amp;p-&gt;lock);
  
  <span class="hljs-keyword">if</span>(schedmode() == <span class="hljs-number">1</span>){
    <span class="hljs-comment">// MLFQ ONLY</span>
    <span class="hljs-type">int</span> nexttq = (p -&gt; tq) + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span>(nexttq &gt;= TIMEQUANTUM(p-&gt;qnum)){
      p -&gt; tq = TIMEQUANTUM(p-&gt;qnum);
    }<span class="hljs-keyword">else</span>{
      p -&gt; tq = nexttq;
    }
    setlastpid(p-&gt;pid);
  }

  p-&gt;state = RUNNABLE;
  sched();
  release(&amp;p-&gt;lock);
}

<span class="hljs-comment">// ==================================================================</span>
<span class="hljs-comment">// 기존 코드 생략..</span>
<span class="hljs-comment">// ==================================================================</span>

<span class="hljs-comment">// returns lastpid</span>
<span class="hljs-type">int</span>
<span class="hljs-title function_">lastp</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>{
  <span class="hljs-type">int</span> pid;
  acquire(&amp;lastpid_lock);
  pid = lastpid;
  release(&amp;lastpid_lock);
  <span class="hljs-keyword">return</span> pid;
}

<span class="hljs-comment">// when yield is called, lastpid stores the pid of the process which called yield</span>
<span class="hljs-type">int</span>
<span class="hljs-title function_">setlastpid</span><span class="hljs-params">(<span class="hljs-type">int</span> pid)</span> 
{
  acquire(&amp;lastpid_lock);
  lastpid = pid;
  release(&amp;lastpid_lock);
  <span class="hljs-keyword">return</span> lastpid;
}

<span class="hljs-comment">// demote the process to the next queue</span>
<span class="hljs-comment">// only used in scheduler() because it assumes that the process is already in the lock</span>
<span class="hljs-type">int</span>
<span class="hljs-title function_">demoteproc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> proc * p)</span>{
  <span class="hljs-keyword">if</span>(p-&gt;qnum == <span class="hljs-number">0</span>){
    p-&gt;qnum = <span class="hljs-number">1</span>;
  }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p-&gt;qnum == <span class="hljs-number">1</span>){
    p-&gt;qnum = <span class="hljs-number">2</span>;
    p-&gt;priority = <span class="hljs-number">3</span>;

  }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p-&gt;qnum == <span class="hljs-number">2</span>){
    p-&gt;qnum = <span class="hljs-number">2</span>;
    <span class="hljs-type">int</span> newpriority = (p-&gt;priority) - <span class="hljs-number">1</span>;

    <span class="hljs-keyword">if</span> (newpriority &lt; <span class="hljs-number">0</span>){
      p-&gt;priority = <span class="hljs-number">0</span>;
    }<span class="hljs-keyword">else</span>{
      p-&gt;priority = newpriority;
    }
  }<span class="hljs-keyword">else</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
  }
  p-&gt;tq = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-type">int</span>
<span class="hljs-title function_">getlev</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> proc *p)</span>{
  <span class="hljs-type">int</span> mode = schedmode();
  <span class="hljs-type">int</span> lev;
  <span class="hljs-keyword">if</span>(mode == <span class="hljs-number">1</span>){
    <span class="hljs-comment">// MLFQ</span>
    acquire(&amp;p-&gt;lock);
    lev = p-&gt;qnum;
    release(&amp;p-&gt;lock);
    <span class="hljs-keyword">return</span> lev;
  }

  <span class="hljs-keyword">return</span> <span class="hljs-number">99</span>;
}

<span class="hljs-type">int</span>
<span class="hljs-title function_">setpriority</span><span class="hljs-params">(<span class="hljs-type">int</span> pid, <span class="hljs-type">int</span> np)</span>{
  <span class="hljs-keyword">if</span>(np &lt; <span class="hljs-number">0</span> || np &gt; <span class="hljs-number">3</span>){
    <span class="hljs-keyword">return</span> <span class="hljs-number">-2</span>;
    <span class="hljs-comment">// invalid priority</span>
  }

  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span>
  <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC];){
    acquire(&amp;p-&gt;lock);
    <span class="hljs-keyword">if</span>(p-&gt;pid == pid){ 
      p-&gt;priority = np; 
      release(&amp;p-&gt;lock);  
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    release(&amp;p-&gt;lock);
    p++;
  }

  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
  <span class="hljs-comment">// not found</span>

}
</code></pre>
<ul>
<li>Variables</li>
</ul>
<table>
<thead>
<tr>
<th>Type</th>
<th>Name</th>
<th>역할</th>
<th>사용</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>int</code></td>
<td><code>lastpid</code></td>
<td>마지막으로 yield한 pid (Syscall, Timer interrupt 무관)</td>
<td><code>proc.c</code></td>
</tr>
<tr>
<td><code>struct spinlock</code></td>
<td><code>lastpid_lock</code></td>
<td><code>lastpid</code>의 atomicity를 보장하기 위한 lock</td>
<td><code>proc.c</code></td>
</tr>
</tbody>
</table>
<ul>
<li>Functions</li>
</ul>
<table>
<thead>
<tr>
<th>Return value</th>
<th>Name(args)</th>
<th>역할</th>
<th>사용</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void</code></td>
<td><code>procinit(void)</code></td>
<td>프로세스 초기화 함수. 각종 lock 및 초기 프로세스의 PCB 구성요소를 초기화한다.</td>
<td><code>proc.c</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>fork(void)</code></td>
<td>새로운 프로세스를 만들 때 호출되는 함수. 모드에 따라 <code>qnum, tq, priority</code>를 다르게 설정한다.</td>
<td><code>sysproc.c</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>yield(void)</code></td>
<td>MLFQ 모드일 때, 그 프로세스의 <code>tq</code>를 하나 증가시킨 뒤, <code>lastpid</code>를 그 프로세스의 <code>pid</code>로 설정한다.</td>
<td><code>trap.c</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>lastp(void)</code></td>
<td><code>lastpid</code>를 atomic하게 return 할 때 쓰는 함수.</td>
<td><code>proc.c</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>setlastpid(int pid)</code></td>
<td><code>yield()</code>가 호출될 때, 호출한 프로세스의 <code>pid</code>를 Set하는 함수.</td>
<td><code>proc.c</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>demoteproc(struct proc *p)</code></td>
<td>MLFQ 스케줄러 내부에서, <code>tq</code>를 다 소모한 프로세스를 demote 하는 함수.<br>프로세스의 정보를 변경하는 만큼, 스케줄러 내부에서 lock이 걸려있다고 가정하고 그 안에서만 사용해야한다.</td>
<td><code>proc.c</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getlev(struct proc *p)</code></td>
<td>프로세스의 <code>qnum</code>을 return 하는 system call. FCFS 모드라면 99를 return 한다.</td>
<td><code>proc.c</code>,<code>mysyscall.c</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>setpriority(int pid, int np)</code></td>
<td>프로세스의 <code>priority</code>를 변경하는 system call.<br>Invalid priority : -2<br>not found a process with pid : -1<br>Successful executiom : 0</td>
<td><code>proc.c</code>,<code>mysyscall.c</code></td>
</tr>
</tbody>
</table>
<h4 id="kerneltrapc"><code>kernel/trap.c</code></h4>
<pre><code class="language-c"><span class="hljs-comment">// ==================================================================</span>
<span class="hljs-comment">// 기존 코드 생략..</span>
<span class="hljs-comment">// ==================================================================</span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">tickslock</span>;</span>
uint ticks;

<span class="hljs-comment">// ==================================================================</span>
<span class="hljs-comment">// 기존 코드 생략..</span>
<span class="hljs-comment">// ==================================================================</span>

<span class="hljs-comment">// reset ticks</span>
<span class="hljs-type">void</span>
<span class="hljs-title function_">resetticks</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
  acquire(&amp;tickslock);
  ticks = <span class="hljs-number">0</span>;
  release(&amp;tickslock);
}
</code></pre>
<ul>
<li>Variables</li>
</ul>
<table>
<thead>
<tr>
<th>Type</th>
<th>Name</th>
<th>역할</th>
<th>사용</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>struct spinlock</code></td>
<td><code>tickslock</code></td>
<td><code>ticks</code>의 atomicity를 보장하기 위한 lock</td>
<td><code>trap.c</code></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>ticks</code></td>
<td>Global tick</td>
<td><code>proc.c</code>, <code>trap.c</code></td>
</tr>
</tbody>
</table>
<ul>
<li>Functions</li>
</ul>
<table>
<thead>
<tr>
<th>Return value</th>
<th>Name(args)</th>
<th>역할</th>
<th>사용</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void</code></td>
<td><code>resetticks(void)</code></td>
<td>Global tick을 0으로 초기화 한다.</td>
<td><code>proc.c</code></td>
</tr>
</tbody>
</table>
<h3 id="scheduler-1"><code>scheduler()</code></h3>
<pre><code class="language-c"><span class="hljs-type">void</span>
<span class="hljs-title function_">scheduler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cpu</span> *<span class="hljs-title">c</span> =</span> mycpu();

  <span class="hljs-comment">// MLFQ only</span>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">mlfq_select</span> =</span> <span class="hljs-number">0</span>;
  <span class="hljs-type">int</span> mlfq_selected = <span class="hljs-number">0</span>;

  c-&gt;proc = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span>(;;){

    intr_on();
    <span class="hljs-type">int</span> found = <span class="hljs-number">0</span>;


	<span class="hljs-comment">// MLFQ</span>
	<span class="hljs-comment">// if global tick is 50, reset all processes. </span>
	<span class="hljs-keyword">if</span>(ticks == <span class="hljs-number">50</span>){
	  <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC];) {
		acquire(&amp;p-&gt;lock);
		<span class="hljs-keyword">if</span>(p-&gt;state == RUNNABLE){
		  p-&gt;qnum = <span class="hljs-number">0</span>;
		  p-&gt;tq = <span class="hljs-number">0</span>;
		  p-&gt;priority = <span class="hljs-number">3</span>;
		}
		release(&amp;p-&gt;lock);
		p++;
	  }
	  resetticks();
	}

	<span class="hljs-comment">// Step 1. If yielded process is RUNNABLE and time quantum is not expired, select it.</span>
	<span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC];) {
	  acquire(&amp;p-&gt;lock);
	  <span class="hljs-keyword">if</span>(p-&gt;pid == lastp() &amp;&amp; p-&gt;pid != yieldp() &amp;&amp; p-&gt;state == RUNNABLE &amp;&amp; p-&gt;tq &lt; TIMEQUANTUM(p-&gt;qnum)){
		mlfq_select = p;
		mlfq_selected = <span class="hljs-number">1</span>;
		<span class="hljs-keyword">break</span>;
	  }

	  release(&amp;p-&gt;lock);
	  p++;
	}

	<span class="hljs-comment">// Step 2. In scheduler, reorder processes.</span>
	<span class="hljs-keyword">if</span>(mlfq_selected == <span class="hljs-number">0</span>){
	  <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC];) {
		acquire(&amp;p-&gt;lock);
		<span class="hljs-keyword">if</span>(p-&gt;pid == lastp() &amp;&amp; p-&gt;state == RUNNABLE &amp;&amp; p-&gt;tq &gt;= TIMEQUANTUM(p-&gt;qnum)){
		  <span class="hljs-comment">// if time quantum is expired, we should demote the process.</span>
		  demoteproc(p);
		}

		release(&amp;p-&gt;lock);
		p++;
	  }
	}

	<span class="hljs-comment">// Step 3. Find a process in L0 queue.</span>
	<span class="hljs-keyword">if</span>(mlfq_selected == <span class="hljs-number">0</span>){
	  <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC];) {
		acquire(&amp;p-&gt;lock);
		<span class="hljs-keyword">if</span>(p-&gt;state == RUNNABLE &amp;&amp; p-&gt;qnum == <span class="hljs-number">0</span> &amp;&amp; p-&gt;pid != yieldp()) {
		  mlfq_select = p;
		  mlfq_selected = <span class="hljs-number">1</span>;
		  <span class="hljs-keyword">break</span>;
		}

		release(&amp;p-&gt;lock);
		p++;
	  }
	}

	<span class="hljs-comment">// Step 4. If there are no process to run in L0 queue, Find a process in L1 queue.</span>
	<span class="hljs-keyword">if</span>(mlfq_selected == <span class="hljs-number">0</span>){
	  <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC];) {
		acquire(&amp;p-&gt;lock);
		<span class="hljs-keyword">if</span>(p-&gt;state == RUNNABLE &amp;&amp; p-&gt;qnum == <span class="hljs-number">1</span> &amp;&amp; p-&gt;pid != yieldp()) {
		  mlfq_select = p;
		  mlfq_selected = <span class="hljs-number">1</span>;
		  <span class="hljs-keyword">break</span>;
		}

		release(&amp;p-&gt;lock);
		p++;
	  }
	}

	<span class="hljs-comment">// Step 5. If there are no process to run in L1 queue, Find a process in L2 queue.</span>
	<span class="hljs-comment">// L2 queue has a scheduling policy of priority_scheduling.</span>
	<span class="hljs-comment">// Since we only have 4 priority levels and the maximum number of process is 64,</span>
	<span class="hljs-comment">// we can just brute force it.</span>

	<span class="hljs-comment">// L2 priority 3</span>
	<span class="hljs-keyword">if</span>(mlfq_selected == <span class="hljs-number">0</span>){
	  <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC];) {
		acquire(&amp;p-&gt;lock);
		<span class="hljs-keyword">if</span>(p-&gt;state == RUNNABLE &amp;&amp; p-&gt;qnum == <span class="hljs-number">2</span> &amp;&amp; p-&gt;priority == <span class="hljs-number">3</span> &amp;&amp; p-&gt;pid != yieldp()) {
		  mlfq_select = p;
		  mlfq_selected = <span class="hljs-number">1</span>;
		  <span class="hljs-keyword">break</span>;
		}

		release(&amp;p-&gt;lock);
		p++;
	  }
	}

	<span class="hljs-comment">// L2 priority 2</span>
	<span class="hljs-keyword">if</span>(mlfq_selected == <span class="hljs-number">0</span>){
	  <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC];) {
		acquire(&amp;p-&gt;lock);
		<span class="hljs-keyword">if</span>(p-&gt;state == RUNNABLE &amp;&amp; p-&gt;qnum == <span class="hljs-number">2</span> &amp;&amp; p-&gt;priority == <span class="hljs-number">2</span> &amp;&amp; p-&gt;pid != yieldp()) {
		  mlfq_select = p;
		  mlfq_selected = <span class="hljs-number">1</span>;
		  <span class="hljs-keyword">break</span>;
		}

		release(&amp;p-&gt;lock);
		p++;
	  }
	}
	<span class="hljs-comment">// L2 priority 1</span>
	<span class="hljs-keyword">if</span>(mlfq_selected == <span class="hljs-number">0</span>){
	  <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC];) {
		acquire(&amp;p-&gt;lock);
		<span class="hljs-keyword">if</span>(p-&gt;state == RUNNABLE &amp;&amp; p-&gt;qnum == <span class="hljs-number">2</span> &amp;&amp; p-&gt;priority == <span class="hljs-number">1</span> &amp;&amp; p-&gt;pid != yieldp()) {
		  mlfq_select = p;
		  mlfq_selected = <span class="hljs-number">1</span>;
		  <span class="hljs-keyword">break</span>;
		}

		release(&amp;p-&gt;lock);
		p++;
	  }
	}

	<span class="hljs-comment">// L2 priority 0</span>
	<span class="hljs-keyword">if</span>(mlfq_selected == <span class="hljs-number">0</span>){
	  <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC];) {
		acquire(&amp;p-&gt;lock);
		<span class="hljs-keyword">if</span>(p-&gt;state == RUNNABLE &amp;&amp; p-&gt;qnum == <span class="hljs-number">2</span> &amp;&amp; p-&gt;priority == <span class="hljs-number">0</span> &amp;&amp; p-&gt;pid != yieldp()) {
		  mlfq_select = p;
		  mlfq_selected = <span class="hljs-number">1</span>;
		  <span class="hljs-keyword">break</span>;
		}

		release(&amp;p-&gt;lock);
		p++;
	  }
	}     
	
	
	<span class="hljs-comment">// Step 6. if selected, swtch it.</span>
	<span class="hljs-keyword">if</span>(mlfq_selected == <span class="hljs-number">1</span>){
	  mlfq_select -&gt; state = RUNNING;
	  c -&gt; proc = mlfq_select;
	  mlfq_selected = <span class="hljs-number">0</span>;

	  swtch(&amp;c-&gt;context, &amp;mlfq_select-&gt;context);
	  c-&gt;proc = <span class="hljs-number">0</span>;
	  found = <span class="hljs-number">1</span>;
	  release(&amp;mlfq_select-&gt;lock);
	}

	<span class="hljs-keyword">if</span>(schedmode() != <span class="hljs-number">1</span>){
	  <span class="hljs-comment">// if the mode is changed, we dont need to break the loop.</span>
	  <span class="hljs-comment">// because mlfq scheduling is done outside of the loop.</span>
	}     
}
<span class="hljs-keyword">if</span>(found == <span class="hljs-number">0</span>) {
  <span class="hljs-comment">// nothing to run; stop running on this core until an interrupt.</span>
  intr_on();
  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;wfi&quot;</span>)</span>;
}

}
</code></pre>
<ul>
<li>Local variables</li>
</ul>
<table>
<thead>
<tr>
<th>Type</th>
<th>Name</th>
<th>역할</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>struct proc *</code></td>
<td><code>p</code></td>
<td>Process table의 iterator.</td>
</tr>
<tr>
<td><code>struct proc *</code></td>
<td><code>mlfq_select</code></td>
<td>Scheduling round 종료 시점에 <code>swtch()</code>할 프로세스를 가리키는 포인터.</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>mlfq_selected</code></td>
<td>multiple Iteration 종료 시점에 <code>mlfq_select</code>가 정해졌는지 아닌지 여부를 나타내는 변수.<br>0 : 선택되지 않음 (default)<br>1 : 선택 됨</td>
</tr>
</tbody>
</table>
<ul>
<li>Specification 반영사항</li>
</ul>
<table>
<thead>
<tr>
<th>Specification</th>
<th>Line Number</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>3개의 queue</td>
<td><code>proc.h</code></td>
<td>Define을 통해 큐와, 큐의 time quantum을 정의함</td>
</tr>
<tr>
<td>새로운 프로세스 생성시 L0으로 배치</td>
<td><code>fork()</code></td>
<td>MLFQ 모드에서 프로세스 생성시 L0큐로 설정함</td>
</tr>
<tr>
<td>L0 -&gt; L1 -&gt; L2 순의 Search</td>
<td>64, 79, 99</td>
<td>순차적으로 Process table iteration</td>
</tr>
<tr>
<td>Time quantum 전부 소모한 Process의 Demotion</td>
<td>56</td>
<td>Time quantum 소모시 <code>demoteproc</code> 호출</td>
</tr>
<tr>
<td>L2의 Priority Scheduling</td>
<td>99, 114, 128, 143</td>
<td>Priority 높은 순으로 Iteration 배치</td>
</tr>
<tr>
<td>Priority Boosting</td>
<td>22</td>
<td>Global tick이 50이 되면 모든 프로세스를 L0으로 이동</td>
</tr>
</tbody>
</table>
<ul>
<li>Design 반영사항</li>
</ul>
<table>
<thead>
<tr>
<th>Design</th>
<th>Line Number</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>MLFQ 스케줄러를 어떻게 구현할까?<br>Multiple Iteration - lock problem</td>
<td>37, 50, 64, 79, 99, 114, 128, 143</td>
<td>Multiple Iteration과 mlfq_select의 lock을 통해 구현하였음.</td>
</tr>
</tbody>
</table>
<h3 id="related-system-call-1">Related System call</h3>
<h4 id="kernelmysyscallc-1"><code>kernel/mysyscall.c</code></h4>
<pre><code class="language-c"><span class="hljs-comment">// ==================================================================</span>
<span class="hljs-comment">// 기존 코드 생략..</span>
<span class="hljs-comment">// ==================================================================</span>

<span class="hljs-type">int</span>
<span class="hljs-title function_">sys_getlev</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();
    <span class="hljs-type">int</span> lev = getlev(p);
    <span class="hljs-keyword">return</span> lev;
}

<span class="hljs-type">int</span>
<span class="hljs-title function_">sys_setpriority</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>{
    <span class="hljs-type">int</span> pid, np;
    argint(<span class="hljs-number">0</span>, &amp;pid);
    argint(<span class="hljs-number">1</span>, &amp;np);
    
    <span class="hljs-keyword">return</span> setpriority(pid, np);
}

</code></pre>
<ul>
<li>Functions</li>
</ul>
<table>
<thead>
<tr>
<th>Return value</th>
<th>Name(args)</th>
<th>역할</th>
<th>사용</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>int</code></td>
<td><code>sys_getlev(void)</code></td>
<td><code>proc.c</code>의 <code>getlev</code>를 호출하는 Wrapper function</td>
<td>User program</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>sys_setpriority(void)</code></td>
<td>User program에서는 <code>int, int</code>의 argument를 전달함. <br>이를 받아서 <code>proc.c</code>의 <code>setpriority</code>함수를 실행함.</td>
<td>User program</td>
</tr>
</tbody>
</table>
<h2 id="3-mode-change">3. Mode change</h2>
<h3 id="전역변수-및-함수-설명-2">전역변수 및 함수 설명</h3>
<h4 id="kernelprocc-2"><code>kernel/proc.c</code></h4>
<pre><code class="language-c"><span class="hljs-comment">// ==================================================================</span>
<span class="hljs-comment">// 기존 코드 생략..</span>
<span class="hljs-comment">// ==================================================================</span>

<span class="hljs-comment">// scheduler mode</span>
<span class="hljs-comment">// 0: FCFS</span>
<span class="hljs-comment">// 1: MLFQ</span>
<span class="hljs-type">int</span> scheduler_mode = <span class="hljs-number">0</span>;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">schedmode_lock</span>;</span>



<span class="hljs-comment">// ==================================================================</span>
<span class="hljs-comment">// 기존 코드 생략..</span>
<span class="hljs-comment">// ==================================================================</span>


<span class="hljs-comment">// 0 : FCFS</span>
<span class="hljs-comment">// 1 : MLFQ</span>
<span class="hljs-type">int</span>
<span class="hljs-title function_">schedmode</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
  <span class="hljs-type">int</span> mode;
  acquire(&amp;schedmode_lock);
  mode = scheduler_mode;
  release(&amp;schedmode_lock);
  <span class="hljs-keyword">return</span> mode;
}

<span class="hljs-comment">// 0 : FCFS</span>
<span class="hljs-comment">// 1 : MLFQ</span>
<span class="hljs-type">int</span>
<span class="hljs-title function_">mlfqmode</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>{
  acquire(&amp;schedmode_lock);
  <span class="hljs-keyword">if</span>(scheduler_mode == <span class="hljs-number">1</span>){
    release(&amp;schedmode_lock);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
  }

  <span class="hljs-comment">// FCFS -&gt; MLFQ</span>
  <span class="hljs-comment">// Move all processes to the first queue</span>
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">struct</span> proc *p = proc; p &lt;= &amp;proc[NPROC];){
    acquire(&amp;p-&gt;lock);
    p-&gt;qnum = <span class="hljs-number">0</span>;
    p-&gt;tq = <span class="hljs-number">0</span>;
    p-&gt;priority = <span class="hljs-number">3</span>;
    release(&amp;p-&gt;lock);
    p++;
  }
  scheduler_mode = <span class="hljs-number">1</span>;
  resetticks();
  release(&amp;schedmode_lock);
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-type">int</span>
<span class="hljs-title function_">fcfsmode</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>{
  acquire(&amp;schedmode_lock);
  <span class="hljs-keyword">if</span>(scheduler_mode == <span class="hljs-number">0</span>){
    release(&amp;schedmode_lock);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
  }

  <span class="hljs-comment">// MLFQ -&gt; FCFS</span>
  <span class="hljs-comment">// Initialize all processes to FCFS</span>
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">struct</span> proc *p = proc; p &lt;= &amp;proc[NPROC];){
    acquire(&amp;p-&gt;lock);
    p-&gt;qnum = FCFSMODE;
    p-&gt;tq = FCFSMODE;
    p-&gt;priority = FCFSMODE;
    release(&amp;p-&gt;lock);
    p++;
  }

  scheduler_mode = <span class="hljs-number">0</span>;
  resetticks();
  release(&amp;schedmode_lock);
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">// Deprecated</span>
<span class="hljs-comment">// 0 : FCFS</span>
<span class="hljs-comment">// 1 : MLFQ</span>
<span class="hljs-type">int</span>
<span class="hljs-title function_">setschedmode</span><span class="hljs-params">(<span class="hljs-type">int</span> mode)</span>
{

  acquire(&amp;schedmode_lock);
  <span class="hljs-keyword">if</span>(mode == scheduler_mode){
    release(&amp;schedmode_lock);

    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
  }<span class="hljs-keyword">else</span>{

    <span class="hljs-keyword">if</span>(mode == <span class="hljs-number">0</span>){
      <span class="hljs-comment">// MLFQ -&gt; FCFS</span>
      <span class="hljs-comment">// Initialize all processes to FCFS</span>
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">struct</span> proc *p = proc; p &lt;= &amp;proc[NPROC];){
        acquire(&amp;p-&gt;lock);
        p-&gt;qnum = FCFSMODE;
        p-&gt;tq = FCFSMODE;
        p-&gt;priority = FCFSMODE;
        release(&amp;p-&gt;lock);
        p++;
      }
    }
    <span class="hljs-keyword">else</span>{
      <span class="hljs-comment">// FCFS -&gt; MLFQ</span>
      <span class="hljs-comment">// Move all processes to the first queue</span>
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">struct</span> proc *p = proc; p &lt;= &amp;proc[NPROC];){
        acquire(&amp;p-&gt;lock);
        p-&gt;qnum = <span class="hljs-number">0</span>;
        p-&gt;tq = TQ_Q0;
        p-&gt;priority = <span class="hljs-number">3</span>;
        release(&amp;p-&gt;lock);
        p++;
      }
    }

    scheduler_mode = mode;
    resetticks();
    release(&amp;schedmode_lock);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  }
}
</code></pre>
<ul>
<li>Variables</li>
</ul>
<table>
<thead>
<tr>
<th>Type</th>
<th>Name</th>
<th>역할</th>
<th>사용</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>int</code></td>
<td><code>schedulermode</code></td>
<td>현재 Scheduler mode를 확인하기 위한 전역 변수</td>
<td><code>proc.c</code></td>
</tr>
<tr>
<td><code>struct spinlock</code></td>
<td><code>schedmode_lock</code></td>
<td>모드 변경 시 atomicity를 유지하기 위한 lock</td>
<td><code>proc.c</code></td>
</tr>
</tbody>
</table>
<ul>
<li>Functions</li>
</ul>
<table>
<thead>
<tr>
<th>Return value</th>
<th>Name(args)</th>
<th>역할</th>
<th>사용</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>int</code></td>
<td><code>schedmode(void)</code></td>
<td>현재 Scheduler mode를 atomic 하게 return 하는 함수</td>
<td><code>proc.c</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>mlfqmode(void)</code></td>
<td>현재 Scheduler mode를 MLFQ로 만드는 함수</td>
<td><code>mysyscall.c</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>fcfsmode(void)</code></td>
<td>현재 Scheduler mode를 FCFS로 만드는 함수</td>
<td><code>mysyscall.c</code></td>
</tr>
<tr>
<td><s><code>int</code></s></td>
<td><s><code>setschedmode(int mode)</code></s></td>
<td>현재 Scheduler mode를 <code>int mode</code>에 따라 MLFQ, FCFS로 바꾸는 함수</td>
<td><em>Depracated</em></td>
</tr>
</tbody>
</table>
<h3 id="scheduler-2"><code>scheduler()</code></h3>
<pre><code class="language-c"><span class="hljs-type">void</span>
<span class="hljs-title function_">scheduler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cpu</span> *<span class="hljs-title">c</span> =</span> mycpu();


  c-&gt;proc = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span>(;;){

    intr_on();
    <span class="hljs-type">int</span> found = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">if</span>(schedmode() == <span class="hljs-number">0</span>){
      <span class="hljs-comment">// FCFS</span>
      <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC];) {
	    <span class="hljs-comment">// FCFS Scheduing Loop</span>
        <span class="hljs-keyword">if</span>(schedmode() != <span class="hljs-number">0</span>){
          <span class="hljs-comment">// if the mode is changed, we should break the loop.</span>
          <span class="hljs-keyword">break</span>;
        }
      }

    <span class="hljs-keyword">else</span>{
        <span class="hljs-comment">// MLFQ    </span>
    }
    <span class="hljs-keyword">if</span>(found == <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// nothing to run; stop running on this core until an interrupt.</span>
      intr_on();
      <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;wfi&quot;</span>)</span>;
    }
  }
}
</code></pre>
<ul>
<li>Specification 반영사항</li>
</ul>
<table>
<thead>
<tr>
<th>Specification</th>
<th>Line Number</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>부팅 시 스케줄러 모드는 FCFS이다</td>
<td><code>proc.c</code></td>
<td><code>scheduler_mode</code>를 0으로 초기화 함.</td>
</tr>
<tr>
<td>모드 전환시 Global tick Reset</td>
<td><code>mlfqmode()</code>, <code>fcfsmode()</code></td>
<td>모드 변경 이후에 <code>resettick()</code>호출</td>
</tr>
<tr>
<td>동일한 모드로의 변화는 에러 메시지 출력 이후 아무런 변화를 일으키지 않음</td>
<td><code>mlfqmode()</code>, <code>fcfsmode()</code></td>
<td>Wrapper function 단위에서 구현함.</td>
</tr>
<tr>
<td>MLFQ -&gt; FCFS</td>
<td><code>fcfsmode()</code>,18</td>
<td>모든 프로세스의 Queue, time quantum, Priority를 -1로 초기화한다. 또한 기존 FCFS 스케줄링 루프 안에 있었을 경우 Loop를 Break 한다.</td>
</tr>
<tr>
<td>FCFS -&gt; MLFQ</td>
<td><code>mlfqmode()</code></td>
<td>모든 프로세스는 L0 Queue로, Priority는 1로 초기화한다.</td>
</tr>
</tbody>
</table>
<ul>
<li>Design 반영사항</li>
</ul>
<table>
<thead>
<tr>
<th>Design</th>
<th>Line Number</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>FCFS 와 MLFQ 스케줄러의 통합</td>
<td>14, 24</td>
<td>동일한 Scheduler 함수 내에서 <code>scheduler_mode</code>값에 따라 다르게 동작한다.</td>
</tr>
<tr>
<td>Previous mode의 검사 (FCFS)</td>
<td>18</td>
<td>MLFQ에서 FCFS로 모드 변환이 발생한 경우, loop를 break 한다.</td>
</tr>
</tbody>
</table>
<h3 id="related-system-call-2">Related System call</h3>
<h4 id="kernelmysyscallc-2"><code>kernel/mysyscall.c</code></h4>
<pre><code class="language-c"><span class="hljs-comment">// ==================================================================</span>
<span class="hljs-comment">// 기존 코드 생략..</span>
<span class="hljs-comment">// ==================================================================</span>

<span class="hljs-type">int</span>
<span class="hljs-title function_">sys_fcfsmode</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>{
    <span class="hljs-keyword">if</span>(fcfsmode() == <span class="hljs-number">-1</span>){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The mode is already fcfs\n&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The mode is now fcfs\n&quot;</span>);
    yield();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-type">int</span>
<span class="hljs-title function_">sys_mlfqmode</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>{
    <span class="hljs-keyword">if</span>(mlfqmode() == <span class="hljs-number">-1</span>){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The mode is already mlfq\n&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The mode is now mlfq\n&quot;</span>);
    yield();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">// ==================================================================</span>
<span class="hljs-comment">// 기존 코드 생략..</span>
<span class="hljs-comment">// ==================================================================</span>
</code></pre>
<ul>
<li>Functions</li>
</ul>
<table>
<thead>
<tr>
<th>Return value</th>
<th>Name(args)</th>
<th>역할</th>
<th>사용</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>int</code></td>
<td><code>sys_fcfsmode(void)</code></td>
<td><code>scheduler_mode</code>를 0으로 바꾸려고 시도한다.<br>만일 이미 0이라면, 에러메시지를 출력하고 -1을 return 한다.</td>
<td>User program</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>sys_mlfqmode(void)</code></td>
<td><code>scheduler_mode</code>를 1로 바꾸려고 시도한다.<br>만일 이미 1이라면, 에러메시지를 출력하고 -1을 return 한다.</td>
<td>User program</td>
</tr>
</tbody>
</table>
<h1 id="results">Results</h1>
<h1 id="troubleshooting">Troubleshooting</h1>

            
            
        </body>
        </html>